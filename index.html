<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Python2 VS.  - Steven</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Python2 v.s Python3</h2>
					<p>
						<small>Created by Steven.Hsiao</small>
					</p>
				</section>

				<section>
					<section>
						<h2>Print</h2>
						<span class="fragment">
						<small>Python 2 doesn’t have a problem with additional parantheses, but in contrast, Python 3 would raise a SyntaxError if we called the print function the Python 2-way without the parentheses.。</small></span>
					
					</section>

					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
print 'Hello, World!'
print('Hello, World!')
print "text", ; print 'print more text on the same line'
Hello, World!
Hello, World!
text print more text on the same line</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
print('Hello, World!')

print("some text,", end="")
print(' print more text on the same line')

Hello, World!
some text, print more text on the same line</code></pre>
					
					</section>

				</section>



				<section>
					<section>
						<h2>Integer division</h2>
						<span class="fragment">
						<small>This change is particularly dangerous if you are porting code, or if you are executing Python 3 code in Python 2, since the change in integer-division behavior can often go unnoticed (it doesn’t raise a SyntaxError).</small></span>
					
					</section>

					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
print '3 / 2 =', 3 / 2
print '3 // 2 =', 3 // 2
print '3 / 2.0 =', 3 / 2.0
print '3 // 2.0 =', 3 // 2.0

3 / 2 = 1
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
print('3 / 2 =', 3 / 2)
print('3 // 2 =', 3 // 2)
print('3 / 2.0 =', 3 / 2.0)
print('3 // 2.0 =', 3 // 2.0)

3 / 2 = 1.5
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0</code></pre>

					
					</section>

					
					
				</section>



				<section>
					<section>
						<h2>Unicode</h2>
						<span class="fragment">
						<small>Python 2 has ASCII str() types, separate unicode(), but no byte type.

Now, in Python 3, we finally have Unicode (utf-8) strings, and 2 byte classes: byte and bytearrays.</small></span>
					
					</section>

					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
print type(unicode('this is like a python3 str type'))
<type 'unicode'>
print type(b'byte type does not exist')
<type 'str'>
print 'they are really' + b' the same'
they are really the same
print type(bytearray(b'bytearray oddly does exist though'))
<type 'bytearray'></code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">print('strings are now utf-8 \u03BCnico\u0394é!')
strings are now utf-8 μnicoΔé!
print('Python', python_version(), end="")
print(' has', type(b' bytes for storing data'))
Python 3.4.1 has <class 'bytes'>
print('and Python', python_version(), end="")
print(' also has', type(bytearray(b'bytearrays')))
and Python 3.4.1 also has <class 'bytearray'>
'note that we cannot add a string' + b'bytes for data'</code></pre>

					
					</section>


					<section>
						<img src="UnicodeBasicIOPy3-3.JPG">

					</section>

					
					
				</section>


				<section>
					<section>
						<h2>Raising exceptions</h2>
						<span class="fragment">
						<small>Where Python 2 accepts both notations, the ‘old’ and the ‘new’ syntax, Python 3 chokes (and raises a SyntaxError in turn) if we don’t enclose the exception argument in parentheses:</small></span>
					
					</section>


					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
raise IOError, "file error" 或
raise IOError("file error")
---------------------------------------------------------------------------
IOError Traceback (most recent call last)

<ipython-input-8-25f049caebb0> in <module>()
----> 1 raise IOError, "file error"


IOError: file error</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
# only can use:
raise IOError("file error")</code></pre>

					
					</section>
	
				</section>





				<section>
					<section>
						<h2>Handling exceptions</h2>
						<span class="fragment">
						<small>Also the handling of exceptions has slightly changed in Python 3. In Python 3 we have to use the “as” keyword now</small></span>
					
					</section>


					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
try:
    let_us_cause_a_NameError
except NameError, err:          # or as
    print err, '--> our error message'</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
# can only use:
try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, '--> our error message')</code></pre>

					
					</section>
	
				</section>


				<section>
					<section>
						<h2>For-loop variables and the global namespace leak</h2>
						<span class="fragment">
						<small>Good news is: In Python 3.x for-loop variables don’t leak into the global namespace anymore!</small></span>
					
					</section>


					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
i = 1
print 'before: i =', i

print 'comprehension: ', [i for i in range(5)]

print 'after: i =', i
before: i = 1
comprehension:  [0, 1, 2, 3, 4]
after: i = 4</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
i = 1
print('before: i =', i)

print('comprehension:', [i for i in range(5)])

print('after: i =', i)
before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1</code></pre>

					
					</section>
	
				</section>






<section>
					<section>
						<h2>Returning iterable objects instead of lists</h2>
						<span class="fragment">
						<small>And for those cases where we really need the list-objects, we can simply convert the iterable object into a list via the list() function.</small></span>
					
					</section>


					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
print range(3)
print type(range(3))
[0, 1, 2]
type 'list'
</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
print(range(3))
print(type(range(3)))
print(list(range(3)))
range(0, 3)
class 'range'
[0, 1, 2]
</code></pre>

					
					</section>

					<section>
						<h6>Some more commonly used functions and methods that don’t return lists anymore in Python 3:</h6>
						<span class="fragment">
						<section>
					<h2>Much more</h2>
					<ul>
						<li>zip()</li>
						<li>map()</li>
						<li>filter()</li>
						<li>dictionary’s .values() method</li>
						<li>dictionary’s .items() method</li>
					</ul>
				</section></span>
					
					</section>





	
				</section>




<section>
					<section>
						<h2>Banker’s Rounding</h2>
						<span class="fragment">
						<small>Python 3 adopted the now standard way of rounding decimals when it results in a tie (.5) at the last significant digits. Now, in Python 3, decimals are rounded to the nearest even number. Although it’s an inconvenience for code portability, it’s supposedly a better way of rounding compared to rounding up as it avoids the bias towards large numbers. For more information, see the excellent Wikipedia articles and paragraphs:</small></span>
					
					</section>


					<section>
						<p class="fragment grow">Py2:</p>
						<pre><code class="hljs">
round(15.5)
16.0
round(16.5)
17.0</code></pre>

<p class="fragment grow">Py3:</p>
						<pre><code class="hljs">
round(15.5)
16
round(16.5)
16</code></pre>

					
					</section>
	
				</section>
			


<!-- TESTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT -->

				

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
